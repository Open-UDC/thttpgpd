#!/bin/bash

function udc_validatetransaction {
# Validate a transaction file. 
# Argument 1: the transaction file to validate
# StdOut:
# * if this is a new and valid transaction:
#       "NewOwnerKeyID TransactionIndexOfPreviousOwner PreviousOwnerKeyID"
#       "grain" for each grain to update.
#       "..."
# Return:
#   * true if OK. In this case also copy the file into "$udcHOME/$Currency/k/$srcKey/v/$SrcN".
#   * 1 if OK but already validated
#   * 2 if OK but we fail copying the file into "$udcHOME/$Currency/k/$srcKey/v/$SrcN".
#   * 4 if we miss some previous validation(s) in our status database. 
#   * 5 if the counter of a grain is too old 
#   * 6 if double spending detected !
#   * 7 if an error in input parameter
#   * 8 if the file is an Invalid PGP Message
#   * 9 if the signing key/account is not recognized
#   * 10 if the used format is unknow
#   * 11 if the currency is unrecognized
#   * 12 if the destination key/account is the signing key/account (transaction to itself)
#   * 13 if the from key/account is not the signing key/account
#   * 14 if the destination key/account is not recognized
#   * 15 if the transaction is invalid because SrcKey already did an other transaction with SrcN index.
#   * 16 if the transaction is invalid because a given grain don't even exist.
#   * 17 if the transaction is invalid because there is at least a grain that SrcKey does not own.
#   * 18 if the transaction is invalid because the pointer on previous transaction is false
# Note : Today date inside PGP MESSAGE are not check.

    [[ -f "$1" ]] || return 7

    local SrcFprint="$(LANGUAGE=en $udc_gpg --verify --batch --no-verbose --with-fingerprint "$1" 2>&1 )" \
    && SrcFprint="$(echo "$SrcFprint" | sed -n ' $s, ,,g ; $s,.*:\([0-9A-F]\{40\}\),\1,p ')" \
    && [[ "$SrcFprint" ]] || return 8

    udc_isaccount "$SrcFprint" || return 9

    local SrcMessage tgrain tnegrain tnprev tKeyIDprev bgrain bnegrain OwnerKeyID bnprev bKeyIDprev etc i

    mapfile -t SrcMessage < <($udc_gpg --decrypt --batch --no-verbose "$1" )
    local srcKey=${SrcMessage[2]} 
    local SrcN=${SrcMessage[3]} 
    local destKey=${SrcMessage[4]}

    #for i in ${!SrcMessage[@]} ; do echo "PRIVMSG $SrcNick :${SrcMessage[$i]}" ; done | $IrcLogpipe >> "$Ircfifo"
    [[ "${SrcMessage[0]}" == "d=t2" ]] || return 10
    [[ "${SrcMessage[1]}" == "$Currency" ]] || return 11
    [[ "$destKey" != $SrcFprint ]] || return 12
    [[ "$srcKey" == $SrcFprint ]] && ((SrcN>0)) || return 13
    udc_isaccount "$destKey" || return 14

    #First check if this transaction is not already validated...
    if [[ -f "$udcHOME/$Currency/k/${srcKey: -16}/v/$SrcN" ]] ; then
        if diff <($udc_gpg --decrypt "$1" 2> /dev/null ) <($udc_gpg --decrypt "$udcHOME/$Currency/k/${srcKey: -16}/v/$SrcN" 2> /dev/null ) >&2 ; then
            return 1
        else
            #echo ":The transaction $SrcN of $srcKey already exist and differs !" >&2
            return 15
        fi
    fi

    unset SrcMessage[0] SrcMessage[1] SrcMessage[2] SrcMessage[3] SrcMessage[4]
    for i in "${!SrcMessage[@]}" ; do 
        read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
        read bgrain bnegrain OwnerKeyID bnprev bKeyIDprev etc < <(udc_db_getstatus $tgrain)
        ((bnegrain>=0)) || return 16
        if ((tnegrain==bnegrain)) ; then # we already did validate a transaction for this grain => double spending !
            #echo -e ":Double Spending detected : $srcKey already give $bgrain $bnegrain"\
            #        "\n   to $OwnerKeyID - cf. transaction $bnprev $bKeyIDprev -" >&2
            return 6
        fi

        ((tnegrain>bnegrain+1)) && return 4
        ((tnegrain<bnegrain)) && return 5 # should not occurs since "$udcHOME/$Currency/k/$srcKey/v/$SrcN" should exist
        #((tnegrain==bnegrain+1)) # only this case remain
        [[ "$OwnerKeyID" == ${SrcFprint: -16} ]] || return 17  # The srcKey is not the owner !
        if ((bnegrain>0)) ; then
            ((bnprev==tnprev)) && [[ "$bKeyIDprev" == $tKeyIDprev ]] || return 18 # previous pointer don't match.
        fi
    done

    for i in "${!SrcMessage[@]}" ; do 
        read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
        echo "$tgrain ${destKey: -16} $SrcN"
    done
    mkdir -p "$udcHOME/$Currency/k/${SrcFprint: -16}/v" \
    && cp "$1" "$udcHOME/$Currency/k/${SrcFprint: -16}/v/$SrcN" || return 2
    mkdir -p "$udcHOME/$Currency/k/${destKey: -16}/u" \
    && echo "$SrcN" >> "$udcHOME/$Currency/k/${destKey: -16}/u/${SrcFprint: -16}" || return 2
}

function UDvalidate {
# Validate a transaction, and update local db.
# Argument 1: the transaction file to validate
# Argument 2 (optionnal): the key to sign and so to validate transaction.
# StdOut: the OpenPGP detached signature if Argument 2 is present an signing is OK.
# Return true if all OK. 253-254 if update local database fail (corrupted !), error_code of udc_validatetransaction in other case.

    local update ret grain key etc account

    update="$(udc_validatetransaction "$1")"
    ret="$?"
    case "$ret" in
        1) echo "OpenUDC 1 Warning : transaction was already validated." ;;
        2) echo "OpenUDC 2 Warning : transaction OK, but storing it fail." ;;
        4) echo "OpenUDC 4 Warning : we miss previous validation(s) in our database." ;;
        5) echo "OpenUDC 5 Error : incorrect grain counter." ;;
        6) echo "OpenUDC 6 Error : double spending detected !" ;;
        7) echo "OpenUDC 7 Error : no input found." ;;
        8) echo "OpenUDC 8 Error : input is not a valid PGP Message." ;;
        9) echo "OpenUDC 9 Error : unrecognized signing key/account." ;;
        10) echo "OpenUDC 10 Error : unknow format." ;;
        11) echo "OpenUDC 11 Error : unrecognized currency." ;;
        12) echo "OpenUDC 12 Error : destination key/account is the signing key/account." ;;
        13) echo "OpenUDC 13 Error : source key/account is not the signing key/account." ;;
        14) echo "OpenUDC 14 Error : unrecognized destination key/account." ;;
        15) echo "OpenUDC 15 Error : source key already did an other transaction with SrcN index." ;;
        16) echo "OpenUDC 16 Error : a given grain don't even exist." ;;
        17) echo "OpenUDC 17 Error : there is at least a grain that SrcKey does not own." ;;
        18) echo "OpenUDC 18 Error : a pointer on previous transaction is false." ;;
    esac

    ((ret<2)) || return "$ret"

    if ! echo "$update" | udc_db_updatestatus ; then 
        echo "OpenUDC 3 Warning : transaction OK, but updating our status database fail."
        return 3
    fi

    [[ "$2" ]] && $udc_gpg --decrypt "$1" 2>/dev/null | $udc_gpg --detach-sign -o - --armor -u "$2"\!

     # Check if the destination is one of our account (and update our available grains if so)
    ((ret==0)) && while read grain key etc ; do
        [[ "$account" ]] || for account in "${myaccounts[@]}" "" ; do
            [[ "${account: -16}" == $key ]] && break ;
        done
        [[ "$account" ]] && echo "$grain" >> "$udcHOME/$Currency/k/${account: -16}/g/${grain%%-*}"  || return 253
    done < <(echo "$update" )

    return $ret
}

function UDvdeamon {
# keep an input file or pipe open, and validate each transaction file which name is written in.
# Argument 1 :  the file or pipe to read new transaction input
# Argument 2 (optionnal):  the key used to sign valid transactions. Default: don't sign anything.
# StdIn : "output tfilename [tsigfile]"  if tsigfile is invalid or not present, implementation may send signed message to the transaction's recipient.
# Return 1 if "tail -f" fail ; do not return if success.

    local key="$2"
    exec 11>&1 ## Create file descriptor 11 to save STDOUT

    trap "ps -o pid,command | while read pid comm ; do [[ \"\$comm\" =~ ^\"tail -f \" ]] && kill \$pid ; done ; rm -rvf \"$TmpDir\"" EXIT

    while read output input ; do
    # If output == '-' ; write to stdout. If output began with '#' the entire line is ignored.
        [[ "${output:0:1}" == "#" ]] && continue
        if [[ "$output" == - ]] ; then
            exec >&11
        else
            exec > "$output" || exec > /dev/null #(redirection to "$output" may fail)
        fi

        read -n 12 header < "$input"

        if [[ "${header::8}" == "sigsize=" ]] ; then
            # There is a detached signature before the expected transaction (which is itself a signed message)
            # This must be the signature of the transaction by the recipient to indicate she/he knows it (if not present bots could send email or xmpp message to advertise her/him).
            sed -n '1d' "$input" | head -c "${header:8}" > "$TmpDir/$input.sig"    
            sed -n '1d' "$input" | tail -c +$((${header:8}+1)) > "$TmpDir/$input.gpg"
            UDvalidate "$TmpDir/$input.gpg" "$key"
            # maybe verify if first signature is a detached one of the transaction, signed by recipient (wich indicate she/he know about this transaction).
        else
            UDvalidate "$input" "$key"
        fi
        # if transaction is not signed by the recipient, maybe alert him.
    done < <(tail -f "$1")
    ## redirect STDOUT to STDOUT, and close fd 11.
    exec >&11
    exec 11>&-
    return 1
}


