#!/bin/bash

function udc_validatetransaction {
# Validate a transaction file. 
# Argument 1: the transaction file to validate
# StdOut:
#   if missing some previous transactions (return 49), for each grain : 
#   "grain graincounter"
#   ... where graincounter is the counter of the grain to reach backward in transacation.
# Return:
#   * true if OK. In this case also copy the file into "$udcHOME/$Currency/k/$srcKey/w/$SrcN".
#   * 6 if OK but destKey is blacklisted. Also copy the file into "$udcHOME/$Currency/k/$srcKey/w/$SrcN".
#   * 9 if OK but still waiting for validation of the majority of publication servers.
#   * 10 if OK and validated by majority of publication servers. (file is now in "$udcHOME/$Currency/k/$srcKey/v/$SrcN").
#   * 16 if OK and validated by majority of publication servers (file is now in "$udcHOME/$Currency/k/$srcKey/v/$SrcN"). But destKey is blacklisted.
#   * 17 if OK but we fail copying the file into "$udcHOME/$Currency/k/$srcKey/w/$SrcN".
#   * 18 if OK but we fail updating our status database.
#   * 20 if SrcKey already did a transaction with SrcN index, but can't know if it is the same, or not.
#   * 21 if SrcKey already did a gray transaction (from nowhere or from double-spending) with this SrcN index.
#   * 22 if SrcKey already did an Invalid transaction (blacklisted) with this SrcN index.
#   * 23 if an error in input parameter
#   * 24 if the file is an Invalid PGP Message (no more occurs in this implementation)
#   * 25 if the signing key/account is not recognized (or file is an Invalid PGP Message in this implementation)
#   * 26 if the signing key/account is blacklisted (precision of error 25)
#   * 27 if the signing key/account is unknown (precision of error 25)
#   * 28 if the used format is unknow
#   * 29 if the currency is unrecognized
#   * 39 if an unknow error occurs.
#   * 49 if we miss some previous validation(s) in our status database. 
## Next return code should imply to blacklist the SrcKey, for exemple by removing it from the keyring.
#   * 50 if a grain with the same counter has been just validated, and SrcKey was not the key validated.
#   * 51 if the transaction is invalid because there is at least a grain that SrcKey does not own.
#   * 52 if the transaction is invalid because the pointer on previous transaction differs from our database.
#   * 53 if the counter of a grain is too old (if this is not an error from the signing key: there is a previous double spending to find...)
#   * 60 if the destination key/account is the signing key/account (transaction to itself)
#   * 61 if the from key/account is not the signing key/account
#   * 62 if the destination key/account is unknown.
#   * 63 if the transaction is invalid because SrcKey already did an other transaction with SrcN index.
#   * 64 if the transaction is invalid because a given grain don't even exist.
#   * 65 if double spending detected !
# Note : Today date inside PGP MESSAGE are not check.

    rm "$TmpDir/trmessage*"
    [[ -f "$1" ]] || return 23

    local SrcFprint SrcMessage
    if SrcFprint="$(udc_readPGPsigned 2>&1 1> "$TmpDir/trmessage")" && [[ "$SrcFprint" ]] ; then
        mapfile -t SrcMessage < "$TmpDir/trmessage"
    else
        return 25
    fi

    local ret=0 tgrain tnegrain tnprev tKeyIDprev bgrain bnegrain OwnerKeyID bnprev bKeyIDprev etc i

    mapfile -t SrcMessage < <($udc_gpg --decrypt --batch --no-verbose "$1" )
    local srcKey=${SrcMessage[2]} 
    local SrcN=${SrcMessage[3]} 
    local destKey=${SrcMessage[4]}

    #for i in ${!SrcMessage[@]} ; do echo "PRIVMSG $SrcNick :${SrcMessage[$i]}" ; done | $IrcLogpipe >> "$Ircfifo"
    [[ "${SrcMessage[0]}" == "d=t2" ]] || return 28
    [[ "${SrcMessage[1]}" == "$Currency" ]] || return 29

    # First check if this transaction is not already Blacklisted (by this daemon !)
    [[ -f "$luddHOME/$Currency/k/${srcFprint: -16}/x/$SrcN" ]] && return 22

    [[ "$destKey" != $SrcFprint ]] || return 60
    [[ "$srcKey" == $SrcFprint ]] && ((SrcN>0)) || return 61
    if ! udc_isaccount "$destKey" ; then
        if udc_isbalcklist "$destKey" ; then
            warnblist=1
        else
            return 62
        fi
    fi

    # Check if this transaction is not already validated (by this daemon !)
    #if udc_GET "${PubServList[0]}//$Currency/k/${srcKey: -16}/v/$SrcN" > "$TmpDir/trmessage_.gpg" ; then # ERROR : daemons MUST only trust themselves.
    if [[ -f "$luddHOME/$Currency/k/${srcKey: -16}/v/$SrcN" ]] ; then
	    if [[ "$(stat -c%s "${srcKey: -16}/v/$SrcN")" == 0 ]] ; then #si le fichier local est vide (parametrage pour economiser de la place) on ne peut etre s√ªr que la trancation est bonne
	        return 20
        elif diff <($udc_gpg --decrypt "$luddHOME/$Currency/k/${srcKey: -16}/v/$SrcN" 2> /dev/null ) "$TmpDir/trmessage" >&2 ; then
            return 11
        else
            #echo ":The transaction $SrcN of $srcKey already exist and differs !" >&2
            return 63
        fi
    fi

    unset SrcMessage[0] SrcMessage[1] SrcMessage[2] SrcMessage[3] SrcMessage[4]
    for i in "${!SrcMessage[@]}" ; do 
        read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
        ((tgrain<1)) && ret=66 && break # invalid given grain counter
        read bgrain bnegrain OwnerKeyID bnprev bKeyIDprev etc < <(udc_db_getstatus 1 $tgrain)
        [[ $bgrain == $tgrain ]] || return 39
        ((bnegrain==-2147483648)) && ret=64 && break # a given grain don't even exist
        ((bnegrain<0)) && ret=64 && break # a given grain has been double-spended.
        if ((tnegrain==bnegrain)) ; then # we already did validate a transaction for this grain => double spending !
            if [[ "$bKeyIDprev" == ${SrcFprint: -16} ]] ; then 
                ret=65
                echo -e ":Double Spending detected : $srcKey already give $bgrain $bnegrain"\
                        "\n   to $OwnerKeyID - cf. its transaction $bnprev $bKeyIDprev -" >&2
            else
                ret=50 # The srcKey is not the owner. It may reveal a previous double-spending.
            fi
            break
        fi

        ((tnegrain>bnegrain+1)) && ret=49 && break
        ((tnegrain<bnegrain)) && ret=53 && break # as "$udcHOME/$Currency/k/$srcKey/v/$SrcN" should exist, if it exist it may reveal a previous double-spending.
        #((tnegrain==bnegrain+1)) # only this case remain
        [[ "$OwnerKeyID" != ${SrcFprint: -16} ]] && ret=51 && break # The srcKey is not the owner. It may reveal a previous double-spending.
        if ((bnegrain>0)) ; then
            ((bnprev==tnprev)) && [[ "$bKeyIDprev" == $tKeyIDprev ]] && ret=52 && break # previous pointer don't match. It may reveal a previous double-spending.
        fi
    done

    if ((ret)) ; then 
        for i in "${!SrcMessage[@]}" ; do 
            read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
            udc_db_getstatus 1 $tgrain
        done
        return $ret
    fi

    mkdir -p "$udcHOME/$Currency/k/${SrcFprint: -16}/v"
    if (($luddSaveTrFile)) ; then
        cp "$1" "$udcHOME/$Currency/k/${SrcFprint: -16}/v/$SrcN" || return 17
    else
        echo -n > "$udcHOME/$Currency/k/${SrcFprint: -16}/v/$SrcN" || return 17
    fi

    for i in "${!SrcMessage[@]}" ; do 
        read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
        echo "$tgrain ${destKey: -16} $SrcN"
    done | udc_db_updatestatus || return 18

    #(($luddLinkTr)) \ # existence or not of detached signature by the recever as an ACK, make this fonctionality useless
    #mkdir -p "$udcHOME/$Currency/k/${destKey: -16}/u" \
    #&& echo "$SrcN" >> "$udcHOME/$Currency/k/${destKey: -16}/u/${SrcFprint: -16}" || return 3
}

function UDvalidate {
# Validate a transaction, and update local db.
# Argument 1: the transaction file to validate
# Argument 2 (optionnal): the key to sign and so to validate transaction.
# StdOut: the OpenPGP detached signature if Argument 2 is present an signing is OK.

    local missing ret grain key etc account

    missing="$(udc_validatetransaction "$1")"
    ret="$?"
    case "$ret" in
        0) echo "OpenUDC 0 OK : transaction accepted" ;;
        10) echo "OpenUDC 10 OK : transaction accepted, but destination is blacklisted" ;;
        11) echo "OpenUDC 11 OK : transaction was already validated." ;;
        17) echo "OpenUDC 17 Warning : transaction OK, but storing it fail." ;;
        18) echo "OpenUDC 18 Warning : transaction OK, but updating our status database fail." ;;
        20) echo "OpenUDC 20 Warning : transaction already exist (unable to determine if it's the same)." ;;
#        21) echo "OpenUDC 22 Warning : transaction already exist... and graylisted !" ;;
        22) echo "OpenUDC 22 Warning : transaction already exist... and blacklisted !" ;;
        23) echo "OpenUDC 23 Warning : no input found." ;;
        24) echo "OpenUDC 24 Warning : input is not a valid PGP Message." ;;
        25) echo "OpenUDC 25 Warning : unrecognized signing key/account. (blacklisted or unknown)" ;;
        26) echo "OpenUDC 26 Warning : blacklisted signing key/account." ;;
        27) echo "OpenUDC 27 Warning : unknown signing key/account." ;;
        28) echo "OpenUDC 28 Warning : unknow format." ;;
        29) echo "OpenUDC 29 Warning : unrecognized currency." ;;
        39) echo "OpenUDC 39 Warning : Internal daemon error" ;;
        49) echo "OpenUDC 49 Warning : we miss previous validation(s) in our database." ;;
        50) echo "OpenUDC 50 Warning if a grain has been just validated, but from a different key. (previously double-spended !??)" ;;
        51) echo "OpenUDC 51 Warning : there is at least a grain that SrcKey does not own. (previously double-spended !??)" ;;
        52) echo "OpenUDC 52 Warning : a pointer on previous transaction is false. (previously double-spended !??)" ;;
        53) echo "OpenUDC 53 Warning : incorrect grain counter (previously double-spended !??)" ;;
        60) echo "OpenUDC 60 Error : destination key/account is the signing key/account." ;;
        61) echo "OpenUDC 61 Error : source key/account is not the signing key/account." ;;
        62) echo "OpenUDC 62 Error : unknown destination key/account." ;;
        63) echo "OpenUDC 63 Error : source key already did an other transaction with SrcN index." ;;
        64) echo "OpenUDC 64 Error : a given grain don't even exist." ;;
        65) echo "OpenUDC 65 Error : double spending detected !" ;;
        *) echo "OpenUDC 39 Warning : Unknow daemon error" ;;
    esac
    
    if ((ret>=50)) ; then
        if ((ret>=60)) ; then
            udc_blacklistTr "$1"
        else
            udc_graylistTr "$1"
        fi
    fi
    ((ret>=40)) && echo "$missing"
    ((ret<15)) || return "$ret"

    [[ "$2" ]] && $udc_gpg --decrypt "$1" 2>/dev/null | $udc_gpg --detach-sign -o - --armor -u "$2"\!

     # Check if the destination is one of our account (and update our available grains if so) # Code to be moved : validation daemon should be detached from personnal accounts.
    ((ret==0)) && while read grain key etc ; do
        [[ "$account" ]] || for account in "${myaccounts[@]}" "" ; do
            [[ "${account: -16}" == $key ]] && break ;
        done
        [[ "$account" ]] && echo "$grain" >> "$udcHOME/$Currency/k/${account: -16}/g/${grain%%-*}"  || return 253
    done < <(echo "$update" )

    return $ret
}

function UDvdeamon {
# keep an input file or pipe open, and validate each transaction file which name is written in.
# Argument 1 :  the file or pipe to read new transaction input
# Argument 2 (optionnal):  the key used to sign valid transactions. Default: don't sign anything.
# StdIn : "output tfilename [tsigfile]"  if tsigfile is invalid or not present, implementation may send signed message to the transaction's recipient.
# Return 1 if "tail -f" fail ; do not return if success.

    local key="$2"
    exec 11>&1 ## Create file descriptor 11 to save STDOUT

    trap "ps -o pid,command | while read pid comm ; do [[ \"\$comm\" =~ ^\"tail -f \" ]] && kill \$pid ; done ; rm -rvf \"$TmpDir\"" EXIT

    while read output input ; do
    # If output == '-' ; write to stdout. If output began with '#' the entire line is ignored.
        [[ "${output:0:1}" == "#" ]] && continue
        if [[ "$output" == - ]] ; then
            exec >&11
        else
            exec > "$output" || exec > /dev/null #(redirection to "$output" may fail)
        fi

        read -n 12 header < "$input"

        if [[ "${header::8}" == "sigsize=" ]] ; then
            # There is a detached signature before the expected transaction (which is itself a signed message)
            # This must be the signature of the transaction by the recipient to indicate she/he knows it (if not present bots could send email or xmpp message to advertise her/him).
            sed -n '1d' "$input" | head -c "${header:8}" > "$TmpDir/$input.sig"    
            sed -n '1d' "$input" | tail -c +$((${header:8}+1)) > "$TmpDir/$input.gpg"
            UDvalidate "$TmpDir/$input.gpg" "$key"
            # maybe verify if first signature is a detached one of the transaction, signed by recipient (wich indicate she/he know about this transaction).
        else
            UDvalidate "$input" "$key"
        fi
        # if transaction is not signed by the recipient, maybe alert him.
    done < <(tail -f "$1")
    ## redirect STDOUT to STDOUT, and close fd 11.
    exec >&11
    exec 11>&-
    return 1
}


