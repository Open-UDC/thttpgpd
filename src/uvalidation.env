#!/bin/bash

function udc_checktransaction {
# Validate localy a transaction file. 
# Argument 1: the transaction file to validate
# StdOut:
#   if something wrong with grain status (return >45), the local status of all grains in the transaction : 
#   "grain n_exchanged OwnerKeyID srcn srcKeyID"
#   ...
# Return:
#   * true if validated (eg: by majority of publication servers, file is in "$udcHOME/$Currency/k/$srcKey/v/$SrcN").
#   * 10 if OK localy (copy file in "$udcHOME/$Currency/k/$srcKey/w/$SrcN").
#   * 11 if OK but still waiting for validation of the majority of publication servers (file is in "$udcHOME/$Currency/k/$srcKey/w/$SrcN").
#   * 17 if OK but we fail copying the file into "$udcHOME/$Currency/k/$srcKey/w/$SrcN".
#   * 18 if OK but we fail updating our status datas.
#   * 20 if SrcKey already did a transaction with SrcN index, but can't know if it is the same, or not.
##   * 21 if SrcKey already did a gray transaction (from nowhere or from double-spending) with this SrcN index.
#   * 22 if SrcKey already did an Invalid transaction (blacklisted) with this SrcN index.
#   * 23 if an error in input parameter
##   * 24 if the file is an Invalid PGP Message (no more occurs in this implementation)
#   * 25 if the signing key/account is not recognized (or file is an Invalid PGP Message in this implementation)
##   * 26 if the signing key/account is blacklisted (precision of error 25)
##   * 27 if the signing key/account is unknown (precision of error 25)
#   * 28 if the used format is unknow
#   * 29 if the currency is unrecognized
#   * 39 if an internal/unknow error occurs.
## transaction with next return code may be saved by daemon : they may be valid or erronous in a futur
#   * 47 if the destination key/account is unknown. #This doesn't imply to blacklist because the client don't have to know all the keys.
#   * 48 if the creation set of a grain in is not existing yet.
#   * 49 if we miss some previous validation(s) in our status datas. 
## Next return code should imply to blacklist the transaction and its SrcKey, for exemple by removing it from the keyring.
#   * 50 if a grain with the same counter has been just validated, and SrcKey was not the key validated.
#   * 51 if the transaction is invalid because there is at least a grain that SrcKey does not own.
#   * 52 if the transaction is invalid because the pointer on previous transaction differs from our datas.
#   * 53 if the counter of a grain is too old (if this is not an error from the signing key: there is a previous double spending to find...)
#   * 60 if the destination key/account is the signing key/account (transaction to itself)
#   * 61 if the from key/account is not the signing key/account
#   * 62 if the transaction is invalid because SrcKey already did an other transaction with SrcN index.
#   * 63 if the transaction is invalid because a given grain don't match the expected format.
#   * 64 if the transaction is invalid because a given grain don't even exist.
#   * 65 if double spending detected !
# Note : Today date inside PGP MESSAGE are not check.

    rm "$TmpDir/trmessage*"
    [[ -f "$1" ]] || return 23

    local SrcFprint SrcMessage
    if SrcFprint="$(udc_readPGPsigned 2>&1 1> "$TmpDir/trmessage")" && [[ "$SrcFprint" ]] ; then
        mapfile -t SrcMessage < "$TmpDir/trmessage"
    else
        return 25
    fi

    local ret=0 warnblist=0 i
    local tgrain tnegrain tnprev tKeyIDprev bgrain bnegrain OwnerKeyID bnprev bKeyIDprev etc

    local srcKey=${SrcMessage[2]} 
    local SrcN=${SrcMessage[3]} 
    local destKey=${SrcMessage[4]}

    #for i in ${!SrcMessage[@]} ; do echo "PRIVMSG $SrcNick :${SrcMessage[$i]}" ; done | $IrcLogpipe >> "$Ircfifo"
    [[ "${SrcMessage[0]}" == "d=t2" ]] || return 28
    [[ "${SrcMessage[1]}" == "$Currency" ]] || return 29

    if ! udc_isaccount "$destKey" ; then
#        if udc_isbalcklist "$destKey" ; then
#            warnblist=1
#        else
            return 47 #This doesn't imply to blacklist because the client don't have to know all the keys.
#        fi
    fi

    ## Compare the transaction with our transaction datas.
    # First check if this transaction is not already Blacklisted (by this daemon !)
    [[ -f "$luddHOME/$Currency/k/${srcFprint: -16}/x/$SrcN" ]] && return 22
    # Then if this transaction is not already validated
    #if udc_GET "${PubServList[0]}//$Currency/k/${srcKey: -16}/v/$SrcN" > "$TmpDir/trmessage_.gpg" ; then # ERROR : daemons MUST only trust themselves.
    if [[ -f "$luddHOME/$Currency/k/${srcFprint: -16}/w/$SrcN" ]] ; then
        if diff <($udc_gpg --decrypt "$luddHOME/$Currency/k/${srcFprint: -16}/w/$SrcN" 2> /dev/null ) "$TmpDir/trmessage" >&2 ; then
            return 11
        else
            #echo ":The transaction $SrcN of $srcFprint already exist and differs !" >&2
            return 62
        fi
    fi
    if [[ -f "$luddHOME/$Currency/k/${srcFprint: -16}/v/$SrcN" ]] ; then
	    if [[ "$(stat -c%s "${srcFprint: -16}/v/$SrcN")" == 0 ]] ; then #si le fichier local est vide (parametrage pour economiser de la place) on ne peut etre s√ªr que la trancation est bonne
	        return 20
        elif diff <($udc_gpg --decrypt "$luddHOME/$Currency/k/${srcFprint: -16}/v/$SrcN" 2> /dev/null ) "$TmpDir/trmessage" >&2 ; then
            return 0
        else
            #echo ":The transaction $SrcN of $srcFprint already exist and differs !" >&2
            return 62
        fi
    fi

    #Check if destKey and srcKey are coherent.
    [[ "$destKey" != $SrcFprint ]] || return 60
    [[ "$srcKey" == $SrcFprint ]] && ((SrcN>0)) || return 61

    ## Compare grain in the transaction with our grain status datas.
    unset SrcMessage[0] SrcMessage[1] SrcMessage[2] SrcMessage[3] SrcMessage[4]
    for i in "${!SrcMessage[@]}" ; do 
        read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
        [[ "$tgrain" =~ ^[0-9]+-([0-9]+)-[0-9]+$ ]] || return 63
        ((BASH_REMATCH[1]>udcNcset)) && ret=48 && break
        read bgrain bnegrain OwnerKeyID bnprev bKeyIDprev etc < <(udc_db_getstatus 1 $tgrain)
        [[ $bgrain == $tgrain ]] || return 39 # should not occurs
        #((bnegrain==-2147483648)) && ret=64 && break # a given grain don't even exist |
        #((bnegrain<0)) && ret=64 && break # a given grain has been double-spended.    |-> Code from asynchonous management attempts.
        ((bnegrain<0)) && ret=64 && break # a given grain don't even exist.
        if ((tnegrain==bnegrain)) ; then # we already did validate a transaction for this grain => double spending !
            if [[ "$bKeyIDprev" == ${SrcFprint: -16} ]] ; then 
                ret=65
                echo -e ":Double Spending detected : $srcKey already give $bgrain $bnegrain"\
                        "\n   to $OwnerKeyID - cf. its transaction $bnprev $bKeyIDprev -" >&2
            else
                ret=50 # The srcKey is not the owner. It may reveal a previous double-spending.
            fi
            break
        fi

        ((tnegrain>bnegrain+1)) && ret=49 && break
        ((tnegrain<bnegrain)) && ret=53 && break # as "$udcHOME/$Currency/k/$srcKey/v/$SrcN" should exist, if it exist it may reveal a previous double-spending.
        #((tnegrain==bnegrain+1)) # only this case remain
        [[ "$OwnerKeyID" != ${SrcFprint: -16} ]] && ret=51 && break # The srcKey is not the owner. It may reveal a previous double-spending.
        if ((bnegrain>0)) ; then
            ((bnprev==tnprev)) && [[ "$bKeyIDprev" == $tKeyIDprev ]] && ret=52 && break # previous pointer don't match. It may reveal a previous double-spending.
        fi
    done

    if ((ret)) ; then 
        for i in "${!SrcMessage[@]}" ; do 
            read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
            udc_db_getstatus 1 $tgrain
        done
        return $ret
    fi

    mkdir -p "$udcHOME/$Currency/k/${SrcFprint: -16}/w"
    if (($luddSaveTrFile)) ; then
        cp "$1" "$udcHOME/$Currency/k/${SrcFprint: -16}/w/$SrcN" || return 17
    else
        echo -n > "$udcHOME/$Currency/k/${SrcFprint: -16}/w/$SrcN" || return 17
    fi

    for i in "${!SrcMessage[@]}" ; do 
        read tgrain tnegrain tnprev tKeyIDprev < <(echo "${SrcMessage[$i]}")
        echo "$tgrain ${destKey: -16} $SrcN"
    done | udc_db_updatestatus || return 18

    return 10

    #(($luddLinkTr)) \ # existence or not of detached signature by the recever as an ACK, make this fonctionality useless
    #mkdir -p "$udcHOME/$Currency/k/${destKey: -16}/u" \
    #&& echo "$SrcN" >> "$udcHOME/$Currency/k/${destKey: -16}/u/${SrcFprint: -16}" || return 3
}

function UDvalidate {
# Validate a transaction, and update local db.
# Argument 1: the transaction file to validate
# Argument 2: its id in the OpenUDC Stream.
# Argument 3 (optionnal): the key to sign and so to validate transaction.
# StdOut: the OpenPGP detached signature if Argument 2 is present an signing is OK.

    local gstatus ret grain key etc account id="$2"

    gstatus="$(udc_checktransaction "$1")"
    ret="$?"
    case "$ret" in
        0) echo "OpenUDC:status:0:$id:OK transaction validated (by publication servers)" ;;
        10) echo "OpenUDC:status:10:$id:OK transaction accepted." ;;
        11) echo "OpenUDC:status:11:$id:OK transaction waiting validation by publication servers." ;;
        17) echo "OpenUDC:status:17:$id:Warning transaction OK, but storing it fail." ;;
        18) echo "OpenUDC:status:18:$id:Warning transaction OK, but updating our status datas fail." ;;
        20) echo "OpenUDC:status:20:$id:Warning transaction already exist (unable to determine if it's the same)." ;;
#        21) echo "OpenUDC:status:22:$id:Warning transaction already exist... and graylisted !" ;;
        22) echo "OpenUDC:status:22:$id:Warning transaction already exist... and blacklisted !" ;;
        23) echo "OpenUDC:status:23:$id:Warning no input found." ;;
#        24) echo "OpenUDC:status:24:$id:Warning input is not a valid PGP Message." ;;
        25) echo "OpenUDC:status:25:$id:Warning unrecognized signing key/account. (blacklisted or unknown)" ;;
#        26) echo "OpenUDC:status:26:$id:Warning blacklisted signing key/account." ;;
#        27) echo "OpenUDC:status:27:$id:Warning unknown signing key/account." ;;
        28) echo "OpenUDC:status:28:$id:Warning unknow format." ;;
        29) echo "OpenUDC:status:29:$id:Warning unrecognized currency." ;;
        39) echo "OpenUDC:status:39:$id:Warning Internal daemon error" ;;
        47) echo "OpenUDC:status:47:$id:Warning unknown destination key/account." ;;
        48) echo "OpenUDC:status:48:$id:Warning the creation set of given grain is not validated yet." ;;
        49) echo "OpenUDC:status:49:$id:Warning we miss previous validation(s) in our datas." ;;
        50) echo "OpenUDC:status:50:$id:Error a grain has been just validated, and from a different key. (previously double-spended !??)" ;;
        51) echo "OpenUDC:status:51:$id:Error there is at least a grain that SrcKey does not own. (previously double-spended !??)" ;;
        52) echo "OpenUDC:status:52:$id:Error a pointer on previous transaction is false. (previously double-spended !??)" ;;
        53) echo "OpenUDC:status:53:$id:Error incorrect grain counter (previously double-spended !??)" ;;
        60) echo "OpenUDC:status:60:$id:Error destination key/account is the signing key/account." ;;
        61) echo "OpenUDC:status:61:$id:Error source key/account is not the signing key/account." ;;
        62) echo "OpenUDC:status:62:$id:Error source key already did an other transaction with SrcN index." ;;
        63) echo "OpenUDC:status:63:$id:Error a given grain don't match expected format." ;;
        64) echo "OpenUDC:status:64:$id:Error a given grain don't even exist." ;;
        65) echo "OpenUDC:status:65:$id:Error double spending detected !" ;;
        *) echo "OpenUDC:status:39:$id:Warning Unknow daemon error" ;;
    esac
    
    if ((ret>=50)) ; then
        udc_blacklistTr "$1" "$ret" "$gstatus"
    fi
    ((ret>=48)) # && echo "$gstatus" # to be formatted in OpenUDC Stream
    ((ret<15)) || return "$ret"

    if [[ "$3" ]] ; then
        echo "OpenUDC:dssize::$id:" # TODO size calculation befor
        $udc_gpg --decrypt "$1" 2>/dev/null | $udc_gpg --detach-sign -o - -u "$3"\!
    fi

    # TODO: If the transaction don't come from a Publication Server, Propagate it to (others) Publication Servers and wait for a majority to respond, else only propagate signature and don't wait.

     # Check if the destination is one of our account (and update our available grains if so) # TODO: Code to be moved : validation daemon should be detached from personnal accounts.
    ((ret==0)) && while read grain key etc ; do
        [[ "$account" ]] || for account in "${myaccounts[@]}" "" ; do
            [[ "${account: -16}" == $key ]] && break ;
        done
        [[ "$account" ]] && echo "$grain" >> "$udcHOME/$Currency/k/${account: -16}/g/${grain%%-*}"  || return 253
    done < <(echo "$update" )

    return $ret
}

## OpenUDC URIs (URNs):

# "openudc:[currency]:accounts:" contains (list of) KeyIDs of actives accounts.
# "openudc:[currency]:accounts:pubring" get the minimalistic OpenPGP certificate of all account.
# "openudc:[currency]:accounts:[KeyID]:a:" get the list of detached signature of a transaction to this account and pending in validation process.
# "openudc:[currency]:accounts:[KeyID]:a:[KeyID].[index]" get a detached signature of a transaction to this account and pending in validation process.
# "openudc:[currency]:accounts:[KeyID]:c:" get a list of detached signature of creation sheet validated by this account.
# "openudc:[currency]:accounts:[KeyID]:w:" get the list of index of transactions made by this account but pending in validation process.
# "openudc:[currency]:accounts:[KeyID]:v:" get the list of index of validated transactions made by this account
# "openudc:[currency]:accounts:[KeyID]:v:[index]" get the transaction made by this account with this index
# "openudc:[currency]:blacklist:" contains (list of) fingerprints of unactives (blacklisted) accounts.
# "openudc:[currency]:csheets:[num].env" get the env part of a validated creation sheet.
# "openudc:[currency]:csheets:[num].list" get the list part of a validated creation sheet.
# "openudc:[currency]:csheets:[num].list.diff" get the diff of the list part of a validated creation sheet.
# "openudc:[currency]:csheets:[num].sheet" get the whole part of a validated creation sheet.
# "openudc:[currency]:csheets:pending."...  get the pending creation sheet.
# "openudc:[currency]:status_t" to get status of some grain
# "openudc:[currency]:grains:[n]-[numcreation]#[index]" where [n] is the power of to calculate a value (=2^n) to get status of (one) grain
# "openudc:post_t?id" to send a transaction (to be validated)
# "openudc:post_k" to send or update an OpenPGP certificate
# "openudc:search_k" to search for an OpenPGP certificate
# "openudc:status_t?id" return status of a sended transaction
# "openudc:[currency]:udbot1:" contains fingerprints of actives bots (ie connected recently).
# "openudc:[currency]:udbot1:pubring" get the certificate of all actives udbot
# "openudc:[currency]:udbot1:self" get "self" OpenPGP certificate.
# "openudc:[currency]:udbot1:[fprs]:[KeyID].[index]" get a detached signature of a transaction validated by this daemon and pending in validation process.
# "openudc:[currency]:in:" Contains list of active notaries
# "openudc:[currency]:in:*:" Contains list of hashed udid2 of active members
# "openudc:[currency]:in:-:" Contains list of udid2 whithout notaries
# "openudc:[currency]:in:[udnot1;...]:[udid2;h;...]:certs" get a(the) personal OpenPGP certificate(s) (with sigs)
# "openudc:[currency]:out:" Contains list of hashed udid2 of members who leave the community
# "openudc:[currency]:pending:" Contains list of udid2 which are pending to enter in the community



function UDreadstream {
    local TmpD line

    TmpD="$(mktemp -d --tmpdir="$TmpDir/" input.XXXX)" || return 2

    while read line ; do
        [[ "$line" =~ ^Content-Type:\ *([[:alnum:]-]+)/([[:alnum:]-]+)\ *\;?(.*)$ ]] && break
    done
    mtype="${BASH_REMATCH[1]}"
    msubtype="${BASH_REMATCH[2]}"
    mparameters="${BASH_REMATCH[3]}"

    case "${mtype,,}" in
      multipart)
# uncomment folowing line which may be commented because off mess with syntax coloration !
        if ! #[[ "$mparameters" =~  boundary=(\"([[:print:]]{1,70})\"|([[:alnum:]-]{1,70})) ]] ; then  # " # the " char mess with vim syntax coloration ...
            echo -e "Content-type: text/udc-report;charset=UTF-8\n\nscode=400\nsreport=\"Invalid boundary in multipart\""
            return
        fi
        boundary="${BASH_REMATCH[2]}"
        # Recursion ... 
        ;;
      application)
        case "${msubtype,,}" in
            pgp-keys)
            ;;
            udc-c-*)
            ;;&
            udc-c-env)
            ;;
            udc-c-sheet)
            ;;
            udc-c-list)
            ;;
            udc-c-ldiff)
            ;;
            udc-c-validation)
            ;;
            udc-t-*)
            ;;&
            udc-t-message)
            ;;
            udc-t-receipt)
            ;;
            udc-t-validation)
            ;;
#        *) # Other subtype are ignored
        esac
        ;;
#        *) # Other mime type are ignored
    esac
}

function UDvdeamon {
# keep an input file or pipe open, and handle each OpenUDC stream  which filename is written in.
# Argument 1 :  the file or pipe to read new entire piece of OpenUDC stream.
# Argument 2 (optionnal):  the key used to sign valid transactions. Default: don't sign anything.
# StdIn : "output tfilename [tsigfile]"  if tsigfile is invalid or not present, implementation may send signed message to the transaction's recipient.
# Return 1 if "tail -f" fail ; do not return if success.

    local key="$2" ret=1 

    trap "ps -o pid,command | while read pid comm ; do [[ \"\$comm\" =~ ^\"tail -f \" ]] && kill \$pid ; done ; rm -rvf \"$TmpDir\"" EXIT

    while read output input ; do
    # If output == '-' ; write to stdout. If output began with '#' the entire line is ignored.
    # Maybe enhanced to break the loop on a special pattern
        [[ "${output:0:1}" == "#" ]] && continue
        if [[ "$output" != - ]] ; then
            if ! UDreadstream < "$input" > "$output" ; then  #(Note: redirection to "$output" may fail)
                echo -e "Content-type: text/udc-report;charset=UTF-8\n\nscode=500\nsreport=\"Internal daemon Error\"" > "$output"
            fi
        else
            UDreadstream < "$input" || echo -e "Content-type: text/udc-report;charset=UTF-8\n\nscode=500\nsreport=\"Internal daemon Error\""
        fi
    done < <(tail -f "$1")
    ps -o pid,command | while read pid comm ; do [[ "$comm" =~ ^"tail -f " ]] && kill $pid ; done
    ## redirect STDOUT to STDOUT, and close fd 11.
    return $ret
}

# Things to re-write and delete :
function garbage {
            [[ "${magic,,}" != openudc ]] && echo "OpenUDC:rep:400:::Bad Protocol" && break
            ##[[ "$id" =~ [\/[:cntrl:]] ]] ...  #TODO
            case "$verb" in
              sze_tras)
            # detached signature of a transaction by the recipient to indicate she/he knows it (if not present bots could send email or xmpp message to advertise her/him).
                if ((value)) && [[ "$id" ]] ; then 
                    head -c $((value)) > "$TmpD/$id.sig"
                else
                    echo "OpenUDC:status:-1::invalid field (assize:$value:$id)"
                    break
                fi
                ;;
              sze_tr__)
                head -c $((value)) > "$TmpD/$id.gpg"
                UDvalidate "$TmpD/$id.gpg" "$key"
                ;;
              sze_trds) # daemon detached signature of a transaction which validate a transaction
                   # If it is a publication server signature, don't propagate the transaction.
                ;;
              #status_t) # status of a transaction, identified by its field "id".
              #get_cenv) # get first part of the creation sheet value.
              #sze_cenv) # response to previous command
              #get_cdif) # get diff of the second part of the creation sheet value.
              #sze_cdif) # response to previous command
              #get_data) # get diff of the second part of the creation sheet value.
              #sze_data) # response to previous command
              #sze__cas) # detached signature of a creation sheet
              *)
                echo "OpenUDC:rep:501::Not Implemented" && break
                ;;
            esac
        done
       # if transaction is not signed by the recipient, maybe alert him.
     # ) < "$input"
      #ret=$? && ((ret)) && break
    done < <(tail -f "$1")
    ps -o pid,command | while read pid comm ; do [[ "$comm" =~ ^"tail -f " ]] && kill $pid ; done
    ## redirect STDOUT to STDOUT, and close fd 11.
    return $ret
}

